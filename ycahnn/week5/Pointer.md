포인터
======

## 포인터의 이해
포인터 : 주소 값이 저장되는 변수를 포인터 변수라 칭한다.
선언, 초기화 방법 : int * ptr = &num;
```
int * ptr = &num;
```
int(주소 값을 저장할 변수num의 자료형)
ptr(포인터 변수의 이름)
&num(변수 num의 주소)

->num의 주소가 1000이라면 ptr에 1000 이 저장된다.

## 포인터 연산자( *, &)

### *의 의미

```
int num = 10;
int * ptr = &num;
*ptr = 20;
```
*ptr은 포인터 변수 "ptr에 저장된 주소 값에 해당하는 위치로 접근"하라는 의미
->num에 20 이 저장된다.

### &의 의미
```
int * ptr = &num;
```
&num은 변수 num이 저장되어있는 메모리의 주소를 나타낸다.(scanf함수에서 입력 값을 저장할 변수 앞에 &를 붙이는 이유)

->즉, *&ptr은 변수 ptr과 동일한 의미


## 포인터와 배열의 관계

### 배열 선언 과정 이해

```
int arr[10];
```

1. 메모리의 어느 공간에 변수 arr이 저장된다(변수는 아니지만, 편의상 변수라 표현)
2. 메모리의 또 다른 어느 공간에 40바이트가 할당이 된다.
3. 변수 arr에는 arr[0]의 주소가 저장이 된다.

-> 배열의 이름 arr에 arr[0]의 주소가 저장이 된다. 즉, arr은 arr[0]의 주소를 저장하는 포인터라고 할 수 있는 것이다.


### 포인터와 배열의 차이

배열의 이름 arr에는 arr[0]의 주소가 저장이 되나, 포인터 변수와 달리 arr에 다른 값을 저장할 수 없다.
따라서 배열을 포인터 상수라고 칭할 수 있다.

```
int num1=0, num2=0;
int* ptr = &num1;
ptr= &num2;   //가능
int arr[0] = {0,};
arr = &num1;  //불가능
```


## ptr[i] == *(ptr+i)

양변의 식은 같은 의미를 갖는다


## 문자열 표현법

### 1. 배열로 선언
->배열의 이름에 저장하는 주소는 변경이 불가능하나, 문자열은 수정 가능('변수 형태의 문자열')

### 2. 포인터를 기반으로 선언
```
char* ptr = "My String"; 
```
->해당 문장을 실행하면 문자열이 그 형태에 상관없이 ptr에 저장되고 그 주소 값이 반환된다.
->ptr에 "M"의 주소값 저장됨
->ptr에 저장하는 주소는 변경이 가능하나, 문자열은 수정 불가('상수 형태의 문자열')


## 포인터 배열이란?
주소 값을 요소로 갖는 배열

## 포인터와 함수의 이해

### 함수 인자 전달 방식

```
int MyFunc(int num)
{
num = num * num;
}

int main()
{
  int age;
  MyFunc(age);
}
```

->age에 저장된 값이 매개변수 num에 복사된다. 따라서 age에 저장되는 값은 바뀌지 않는다.


### 배열을 함수의 인자로 전달?

함수의 매개변수에 포인터를 선언하고 직접 배열의 주소에 접근해야 한다.

### call-by-value와 call-by-reference  
#### call-by-value: 인자에 단순이 값을 전달(변수에 저장된 값이 복사되어 인자에 전달되기 때문에, 변수에 저장된 값은 바뀌지 않는다)

#### call-by-reference: 인자에 주소를 전달(직접 주소에 접근하여 변수에 저장된 값을 바꾸는 것이 가능하다)


## 포인터 대상의 const 선언(코드의 안전성 확보)
```
const int* ptr = &num;
```
->num에 저장된 값을 바꾸는 것은 가능하나, ptr을 이용해서 num에 저장된 값을 바꿀 수는 없다.
```
int* const ptr = &num;
```
->ptr에 저장된 num의 주소 값을 바꿀 수 없다.


